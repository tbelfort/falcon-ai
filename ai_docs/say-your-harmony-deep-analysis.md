# Say-Your-Harmony: Deep Analysis

## What It Claims To Be

A "self-improving 4-phase development orchestration system" with:
- Meta-analysis learning loop
- 20-44% efficiency gains
- Pattern reuse across sessions
- Decision caching
- Web search elimination

## What It Actually Is

A **write-only pattern collection system** that:
- Extracts patterns after each phase
- Stores them to disk
- Never loads them back into agents

---

## The 4-Phase Workflow

```
Planning → Design → Implementation → Operation
```

Each phase has a dedicated agent:
- **planner** (opus) - Requirements gathering
- **architect** (opus) - Architecture decisions
- **builder** (sonnet) - Parallel implementation
- **operator** (sonnet) - Deployment, verification

This workflow structure is real and functional.

---

## The Meta-Learning System

### What Gets Extracted (Rich)

After each phase, `phase-meta-extractor` (haiku) extracts:

```json
{
  "accomplishment": "What was achieved",
  "keyInsight": "Main lesson learned",
  "decisions": [{"what": "...", "why": "...", "impact": "high"}],
  "challenges": [{"problem": "...", "resolution": "..."}],
  "risks": [{"severity": "P0", "description": "..."}],
  "approaches": ["parallel-execution", "test-driven"],
  "toolsUsed": ["Read", "Task", "Write"],
  "sequentialDeps": ["db-schema-created"],
  "parallelSuccesses": ["component-a", "component-b"]
}
```

### What Gets Stored (Narrow)

Only TWO fields are merged into cumulative `patterns.json`:

| Field | Purpose |
|-------|---------|
| `sequentialDeps` | "Things that must happen before this phase" |
| `parallelSuccesses` | "Things that can run in parallel" |

Everything else (decisions, insights, approaches) is **discarded** from the learning loop.

### What Gets Injected (Nothing)

**Zero patterns are automatically injected into agents.**

The functions exist:
- `recommendPatterns(phase, limit)` - Returns high-confidence patterns
- `loadHighConfidencePatterns(phase)` - Loads patterns >0.7 confidence
- `getSafeParallelPatterns(phase)` - What can parallelize
- `getAntiPatterns(phase)` - What to avoid

But they are **never called**. Dead code.

---

## The Broken Feedback Loop

```
Phase completes
      ↓
phase-meta-extractor runs
      ↓
Patterns written to ~/.claude/meta/patterns.json
      ↓
      ↓
      ↓   ← LOOP BREAKS HERE
      ↓
[NOTHING READS THEM BACK]
      ↓
Agents run without learned patterns
```

---

## Pattern Matching: Fragile Design

### How Patterns Are Named

The LLM (Haiku) **invents** pattern names based on conversation:

```
Conversation: "I created the database schema..."
Extractor outputs: sequentialDeps: ["db-schema-created"]
```

The name `"db-schema-created"` is **generated by the LLM**, not extracted verbatim.

### How Patterns Are Matched

**Exact string equality:**

```typescript
const existing = patterns.sequentialDeps.find(p => p.id === depId);
//                                                       ===
```

### The Problem

If the LLM names the same concept differently:
- Session 1: `"db-schema-created"`
- Session 2: `"database-schema-done"`
- Session 3: `"schema-creation-complete"`

These are stored as **three separate patterns**. No deduplication.

### v1.3.0 Improvement

Added TF-IDF fuzzy matching (0.9 threshold) and agglomerative clustering (0.75 similarity). But the injection is still missing.

---

## What The System Actually Learns

**Scheduling optimization only:**

| Pattern Type | Meaning |
|--------------|---------|
| `sequentialDeps` | "Don't start until X is done" |
| `parallelSuccesses` | "These can run at the same time" |

NOT learning:
- What approaches work
- What decisions are good
- What tools to use when
- Domain knowledge
- Code quality patterns

**It's a task scheduler optimizer, not a knowledge system.**

---

## The Two Storage Layers

### Machine Layer (Auto, Narrow)

```
~/.claude/meta/{phase}/patterns.json

Contents:
- sequentialDeps (accumulated)
- parallelSuccesses (accumulated)
- [NOT injected into agents]
```

### Human Layer (Manual, Rich)

```
~/.claude/meta/session-*.md
~/.claude/meta/PATTERNS.md

Contents:
- Full meta-analysis (8 sections)
- Decisions, insights, approaches
- [NOT auto-injected, for human reading]
```

---

## README Claims vs Reality

| Claim | Reality |
|-------|---------|
| "Decision Cache Effect (67% reduction)" | Decisions not stored in patterns.json |
| "Knowledge Base Effect (web search elimination)" | session-*.md not auto-injected |
| "Pattern Library Effect" | Only scheduling patterns, not code patterns |
| "20-44% efficiency gains" | Cannot come from the implemented system |

---

## v1.3.0 Changes

### Added
- 8 pattern types (including decision, approach, anti-pattern)
- TF-IDF deduplication (0.9 threshold)
- Agglomerative clustering (0.75 similarity)
- `recommendPatterns()` function
- `loadHighConfidencePatterns()` function

### Still Missing
- **Calling** recommendPatterns() anywhere
- **Injecting** patterns into agents
- **Closing** the feedback loop

The infrastructure improved. The integration is still absent.

---

## File Structure (v1.3.0)

```
src/lib/meta/
├── api/
│   ├── aggregate.ts    # Session aggregation
│   ├── evolve.ts       # Pattern evolution
│   ├── load.ts         # Load patterns (NEVER CALLED by agents)
│   └── save.ts         # Save patterns (WORKS)
├── core/
│   ├── schema.ts       # 8 pattern types defined
│   ├── storage.ts      # CRUD operations
│   └── validator.ts    # Schema validation
├── evolution/
│   ├── clustering.ts   # Agglomerative clustering
│   ├── confidence.ts   # Confidence scoring
│   ├── decay.ts        # Time decay (90-day half-life)
│   ├── deduplication.ts # TF-IDF matching
│   └── eviction.ts     # Low-score removal
├── export/
│   └── markdown.ts     # PATTERNS.md generation
├── extraction/
│   └── extractor.ts    # Pattern extraction
├── query/
│   ├── recommendations.ts  # recommendPatterns() (DEAD CODE)
│   ├── search.ts           # Search functions (DEAD CODE)
│   └── validator-deps.ts   # Dependency validation (DEAD CODE)
└── sessions/
    └── session-store.ts    # Session persistence
```

---

## Where Injection Should Happen

In `src/index.ts`, function `createHarmonySession()`:

```typescript
// Current code builds system prompt from static strings
// Missing: load patterns and inject them

// Should be:
const patterns = await recommendPatterns('planning', 5);
systemPrompt += formatPatterns(patterns);
```

Approximately 10 lines of code would close the loop.

---

## Summary

Say-Your-Harmony has:
- A functional 4-phase workflow ✅
- Rich pattern extraction ✅
- Sophisticated storage (v1.3.0) ✅
- Pattern query API ✅
- **Pattern injection into agents** ❌

The system collects data but never uses it. The README describes a feedback loop that doesn't exist in the code.

---

## Verdict

**The meta-learning system is architecturally complete but functionally disconnected.**

All the pieces exist. They're just not wired together.
